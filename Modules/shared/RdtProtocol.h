/**
 * @file RdtProtocol.h
 * @brief Defines the binary/JSON protocol structures for network communication.
 *
 * This file contains the Pure C++ Data Transfer Objects (DTOs) used to serialize
 * and deserialize data sent between the HMI (Qt) and the Robot Controller (Pure C++).
 * These structures are designed to be serialized directly into JSON using the
 * nlohmann/json library.
 *
 * @namespace Rdt
 * @brief Robot Data Transfer namespace.
 */

#ifndef RDT_PROTOCOL_H
#define RDT_PROTOCOL_H

#include <vector>
#include <array>
#include <string>
#include <cstdint>

namespace Rdt {

/**
 * @brief Enumeration of packet types for message discrimination.
 * Used in the JSON "type" field to determine how to parse the "payload".
 */
enum class PacketType : int {
    /// @brief Packet containing the full robot status (Controller -> HMI).
    STATUS_UPDATE = 100,
    /// @brief Packet containing control commands (HMI -> Controller).
    CONTROL_STATE = 200
};

/**
 * @brief Represents the physical motion state of the robot.
 * Includes joint angles, Cartesian poses, and motion flags.
 */
struct MotionState {
    /**
     * @brief Actual joint angles measured by encoders.
     * @details Array index corresponds to axis index (0-5).
     * @unit Degrees
     */
    std::array<double, 6> actualJoints = {0.0};

    /**
     * @brief Target joint angles generated by the trajectory planner.
     * @details In simulation mode, this drives the visualization immediately.
     * @unit Degrees
     */
    std::array<double, 6> plannedJoints = {0.0};

    /**
     * @brief Actual Cartesian pose of the Tool Center Point (TCP).
     * @details Calculated via Forward Kinematics based on `actualJoints`.
     * Format: {X, Y, Z, A, B, C} (Euler angles ZYX).
     * @unit mm, Degrees
     */
    std::array<double, 6> actualTcp = {0.0};

    /**
     * @brief Target Cartesian pose of the TCP.
     * @details Calculated via Forward Kinematics based on `plannedJoints`.
     * @unit mm, Degrees
     */
    std::array<double, 6> plannedTcp = {0.0};

    /**
     * @brief Pose relative to the currently active user frame/tool.
     * @details Used for displaying coordinates in the UI relative to selected contexts.
     * @unit mm, Degrees
     */
    std::array<double, 6> monitorPose = {0.0};

    /// @brief True if the robot is currently executing a trajectory or jogging.
    bool isMoving = false;

    /// @brief True if the controller is in physics simulation mode (no hardware connection).
    bool isSimulated = true;

    /// @brief Current speed scaling factor (0.0 to 1.0).
    double speedRatio = 0.0;
};

/**
 * @brief System-level status flags and health metrics.
 */
struct SystemState {
    /// @brief True if Emergency Stop is engaged.
    bool isEStop = false;

    /// @brief True if motors are powered and brakes released.
    bool isPowerOn = false;

    /// @brief ID of the active error (0 if no error).
    int activeErrorId = 0;

    // --- Monitoring Data ---

    /// @brief CPU usage of the controller (0.0 - 100.0).
    double cpuLoad = 0.0;

    /// @brief Main controller temperature in Celsius.
    double controllerTemp = 0.0;

    /// @brief Estimated network round-trip time in milliseconds.
    double networkLatency = 0.0;
};

/**
 * @brief State of the robot program interpreter.
 */
struct ProgramState {
    /// @brief True if a program is currently executing.
    bool isRunning = false;

    /// @brief True if execution is paused.
    bool isPaused = false;

    /// @brief Index of the currently executing step in the program list (-1 if stopped).
    int currentLine = -1;

    /// @brief Name of the currently loaded program. Max 64 chars.
    char programName[64] = {0};
};

/**
 * @brief Definition of a Tool (TCP) or Base (Frame).
 */
struct ToolData {
    /// @brief Unique identifier (0-9).
    int id = 0;

    /// @brief Human-readable name.
    std::string name;

    /**
     * @brief Spatial offset {X, Y, Z, A, B, C}.
     * @unit mm, Degrees
     */
    std::array<double, 6> offset = {0.0};
};

/**
 * @brief Master configuration of the robot controller.
 * Contains definitions for all tools, bases, and limits.
 */
struct ControllerConfig {
    /// @brief List of available tools (TCPs). Fixed size of 10 in MockController.
    std::vector<ToolData> tools;

    /// @brief List of available bases (User Frames). Fixed size of 10 in MockController.
    std::vector<ToolData> bases;

    /// @brief IP address of the controller interface.
    std::string ipAddress;

    /**
     * @brief Soft limits for each axis.
     * @details axisLimits[i][0] = Min, axisLimits[i][1] = Max.
     * @unit Degrees
     */
    std::array<double, 2> axisLimits[6];
};

/**
 * @brief Single point in 3D space for trajectory visualization.
 */
struct TrajectoryPoint {
    double x, y, z;
};

/**
 * @brief Full trajectory path for visualization.
 * Sent from Controller to HMI when a program is loaded or changed.
 */
struct TrajectoryPath {
    /// @brief Dense list of points representing the path curve.
    std::vector<TrajectoryPoint> points;

    /// @brief Sparse list of points representing command targets (waypoints).
    std::vector<TrajectoryPoint> waypoints;
};

/**
 * @brief A single command step in a robot program.
 */
struct ProgramStep {
    /// @brief Unique step ID (usually sequence index).
    int id;

    /// @brief Command type: 0 = Motion, 1 = Logic.
    int type;

    /// @brief Target joint angles for motion commands.
    std::array<double, 6> targetJoints;

    /// @brief Movement speed (0-100%).
    double speed;

    /// @brief String representation of the command code (e.g., "MOVJ", "MOVL").
    std::string commandCode;
};

/**
 * @brief Container for a complete robot program.
 */
struct ProgramData {
    std::string name;
    std::vector<ProgramStep> steps;
};

// =============================================================================
// CONTROL STATE (HMI -> Controller)
// =============================================================================

/**
 * @brief State sent from HMI to Controller to command the robot.
 * @details Sent periodically (~50Hz). Contains both continuous state (jog)
 * and transactional requests (config update).
 */
struct ControlState {
    /// @brief Incrementing counter for jog requests to ensure order.
    uint32_t jogRequestId = 0;

    /// @brief Axis index to jog (0-5), or -1 for no jog.
    int jogAxis = -1;

    /// @brief Increment amount for jogging (Degrees). Can be negative.
    double jogIncrement = 0.0;

    /// @brief Global speed override (0.0 - 1.0).
    double speedOverride = 0.5;

    /// @brief True to request physical robot movement, False for simulation.
    bool enableRealMode = false;

    /// @brief ID of the tool context for monitoring coordinates.
    int monitorToolId = 0;

    /// @brief ID of the base context for monitoring coordinates.
    int monitorBaseId = 0;

    // --- Safety ---

    /// @brief True to trigger Emergency Stop.
    bool setEStop = false;

    /// @brief True to reset Emergency Stop state.
    bool resetEStop = false;

    // --- Program Control ---

    /**
     * @brief Command for program execution.
     * 0: None, 1: Start, 2: Pause, 3: Stop, 4: Move Home.
     */
    int programCommand = 0;

    /// @brief Index of the step to highlight/preview (not currently used).
    int previewStepIndex = -1;

    // --- Sync Acknowledgements ---

    /// @brief Last received config version from Controller.
    uint32_t ackConfigVersion = 0;

    /// @brief Last received trajectory version from Controller.
    uint32_t ackTrajVersion = 0;

    /// @brief Last received program version from Controller.
    uint32_t ackProgramVersion = 0;

    // --- Transactional Requests ---

    /// @brief Non-zero ID implies a request to update controller configuration.
    uint32_t configUpdateReqId = 0;

    /// @brief New configuration payload (valid only if configUpdateReqId > 0).
    ControllerConfig newConfig;

    /// @brief Non-zero ID implies a request to upload a new program.
    uint32_t programUpdateReqId = 0;

    /// @brief New program payload (valid only if programUpdateReqId > 0).
    ProgramData newProgram;
};

// =============================================================================
// ROBOT STATUS (Controller -> HMI)
// =============================================================================

/**
 * @brief Complete status snapshot sent from Controller to HMI.
 * @details Sent periodically (~50Hz).
 */
struct RobotStatus {
    /// @brief Server-side timestamp (Unix epoch ms).
    uint64_t timestamp = 0;

    /// @brief Current motion state.
    MotionState motion{};

    /// @brief Current system state.
    SystemState sys{};

    /// @brief Current program execution state.
    ProgramState prog{};

    // --- Transaction Acknowledgements ---

    /// @brief ID of the last processed jog request.
    uint32_t processedJogId = 0;

    /// @brief ID of the last processed config update request.
    uint32_t processedConfigReqId = 0;

    /// @brief ID of the last processed program upload request.
    uint32_t processedProgramReqId = 0;

    // --- Data Versions (for Sync) ---

    /// @brief Current version of the configuration on the controller.
    uint32_t configVersion = 0;

    /// @brief Current version of the trajectory cache.
    uint32_t trajVersion = 0;

    /// @brief Current version of the loaded program.
    uint32_t programVersion = 0;

    // --- Heavy Payloads (Sent only on version mismatch) ---

    /// @brief Active configuration (populated if ackConfigVersion mismatch).
    ControllerConfig config;

    /// @brief Active trajectory visualization (populated if ackTrajVersion mismatch).
    TrajectoryPath trajectory;

    /// @brief Loaded program structure (populated if ackProgramVersion mismatch).
    ProgramData loadedProgram;
};

} // namespace Rdt

#endif // RDT_PROTOCOL_H
